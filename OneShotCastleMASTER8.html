<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Shot Castle: The Last Stand (Definitive Edition)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Uncial+Antiqua&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'MedievalSharp', cursive;
 background-color: #2c2a31; background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://www.transparenttextures.com/patterns/stone-wall.png'); color: #e0dcd1;
 }
        .title-font { font-family: 'Uncial Antiqua', cursive;
 }
        .stone-button { background-color: #4a4650; border: 2px solid #312e36;
 box-shadow: 0 5px 0 #312e36, 0 6px 10px rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; transform: translateY(0);
 }
        .stone-button:active { transform: translateY(4px); box-shadow: 0 1px 0 #312e36;
 }
        .stone-button:disabled { background-color: #312e36; box-shadow: 0 5px 0 #1e1c21; cursor: not-allowed;
 color: #6b6672; }
        .kill-switch { background-color: #8c2a2a; border-color: #5a1d1d;
 box-shadow: 0 5px 0 #5a1d1d, 0 6px 10px rgba(0,0,0,0.5); color: #f0e6e6;
 }
        .kill-switch:active { box-shadow: 0 1px 0 #5a1d1d;
 }
        .main-container { border: 8px solid; border-image-slice: 1; border-width: 8px;
 border-image-source: linear-gradient(to bottom, #7b7b7b, #4a4a4a); background: rgba(44, 42, 49, 0.9); box-shadow: 0 0 40px rgba(0,0,0,0.8);
 }
        .alchemist-die { background-color: #2a6f68; border-color: #1a4742; box-shadow: 0 5px 0 #1a4742; }
        .load-cannon-label { cursor: pointer; background-color: #3a4c62; border-color: #24303d; box-shadow: 0 5px 0 #24303d; }
        select { background-color: #312e36; border: 2px solid #4a4650; }
        #scribe-log-container { font-family: 'Courier New', monospace; background-color: #1e1c21;
 border: 2px solid #4a4650; max-height: 150px; overflow-y: auto; text-align: left; padding: 10px; font-size: 0.8rem; margin-top: 20px;
 }
        #scribe-log-container p { margin: 0; padding: 2px 0; border-bottom: 1px solid #312e36; }
        #scribe-log-container .log-error { color: #ff6b6b; } #scribe-log-container .log-warn { color: #f9ca24; }
        #scribe-log-container .log-info { color: #7bed9f; } #scribe-log-container .log-success { color: #00ffab; font-weight: bold; }
        .effect-button { background-color: #312e36; border: 2px solid #4a4650; color: #a09da8; }
        .effect-button.active { background-color: #5a1d1d; border-color: #8c2a2a; color: #f0e6e6; font-weight: bold; }
        #byrds-mode-button.active { background-color: #6d28d9; border-color: #4c1d95; box-shadow: 0 5px 0 #4c1d95; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="main-container w-full max-w-4xl p-6 sm:p-10 rounded-lg text-center">
        
        <h1 class="title-font text-4xl sm:text-6xl text-[#d4af37] drop-shadow-[0_2px_2px_rgba(0,0,0,0.9)] mb-2">One Shot Castle</h1>
        <p class="mb-6 text-lg text-gray-300">The Last Stand (Definitive Edition)</p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <button id="generate-button" class="stone-button w-full py-4 px-6 rounded-lg text-xl font-bold uppercase tracking-widest text-yellow-100">Forge New Sound</button>
            <button id="replay-button" class="stone-button w-full py-4 px-6 rounded-lg text-xl font-bold uppercase tracking-widest text-green-200" disabled>Re-Trigger Sound</button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center mb-8">
            <div>
                <label for="synth-selector" class="text-gray-400 mr-2">Forged Instrument:</label>
                <select id="synth-selector" class="p-2 rounded-md max-w-xs"></select>
            </div>
            <button id="byrds-mode-button" class="stone-button font-bold py-2 px-4 rounded">Byrds Mode: OFF</button>
        </div>
        <div class="text-center mb-8">
             <button id="reset-button" class="kill-switch font-bold py-2 px-4 rounded">Reset Audio Engine</button>
        </div>

        <div id="the-armory" class="mt-8 pt-6 border-t-4 border-gray-600">
             <h2 class="title-font text-2xl text-yellow-200 mb-4">The Royal Armory</h2>
             <div class="bg-black/20 p-4 rounded-lg">
                <p id="cannon-status" class="mb-2 text-gray-400">The cannon is unloaded.</p>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 items-center">
                    <div>
                        <label for="load-cannon-input" id="load-cannon-label" class="load-cannon-label stone-button text-white font-bold py-2 px-4 rounded inline-block text-center">Load the Cannon</label>
                        <input type="file" id="load-cannon-input" class="hidden" accept="audio/wav, audio/mpeg, audio/ogg, .wav, .mp3, .ogg">
                    </div>
                    <button id="fire-cannon-button" class="stone-button text-orange-200 font-bold py-2 px-4 rounded" disabled>Fire!</button>
                    <button id="ceasefire-button" class="kill-switch font-bold py-2 px-4 rounded" disabled>Ceasefire!</button>
                </div>
             </div>
        </div>

        <div id="alchemist-lab" class="mt-8 pt-6 border-t-4 border-gray-600">
            <h2 class="title-font text-2xl text-yellow-200 mb-4">The Alchemist's Lab</h2>
            <div class="bg-black/20 p-4 rounded-lg space-y-4">
                <div id="effects-grid" class="grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-5 gap-2"></div>
                 <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 items-center mt-4">
                    <button id="randomize-effects-toggle" class="stone-button font-bold py-2 px-4 rounded">Randomize FX: ON</button>
                    <button id="alchemist-die-button" class="stone-button alchemist-die font-bold py-2 px-4 rounded">Roll for New Effects</button>
                    <button id="disengage-all-effects" class="kill-switch font-bold py-2 px-4 rounded">Disengage All FX</button>
                </div>
            </div>
        </div>

        <div id="midi-control-room" class="mt-8 pt-6 border-t-4 border-gray-600">
            <h2 class="title-font text-2xl text-yellow-200 mb-4">MIDI Control Room</h2>
            <div class="bg-black/20 p-4 rounded-lg space-y-4">
                <p id="midi-status" class="text-gray-400">Connect a MIDI device to begin.</p>
                <button id="connect-midi-button" class="stone-button w-full font-bold py-2 px-4 rounded">Scan for MIDI Devices</button>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-center">
                    <select id="midi-devices" class="w-full p-2 rounded-md hidden" disabled></select>
                    <button id="midi-note-target-toggle" class="stone-button font-bold py-2 px-4 rounded" disabled>MIDI Triggers: Synth</button>
                </div>
                 <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-center">
                    <button id="midi-cc-target-toggle" class="stone-button font-bold py-2 px-4 rounded" disabled>CC Control: Synth</button>
                     <div id="active-effects-controls" class="hidden">
                        <select id="active-effects-dropdown" class="w-full p-2 rounded-md"></select>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-12">
             <button id="kill-switch" class="kill-switch w-full max-w-xs py-3 px-4 rounded-md text-md font-bold uppercase">Silence All</button>
        </div>
        
        <div id="scribe-log-container" class="rounded-lg mt-8"></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE VARIABLES ---
        let activeNode = null, cannonPlayer = null, lastSynthConfig = null;
        let activeEffects = [], midiCCMap = {};
        let isAudioReady = false, isGenerating = false, randomizeEffects = true, midiAccess = null;
        let masterLimiter, effectsBus, masterVolume;
        let midiCCTarget = 'synth', midiNoteTarget = 'synth', activeMIDIInput = null;
        let byrdsMode = { isActive: false, compressor: null, pitchShift: null, vibrato: null, split: null, wet: null, dry: null, highEndFilter: null, makeupGain: null };
        
        const synthList = ['FMSynth','AMSynth','DuoSynth','Synth', 'MonoSynth','MembraneSynth','MetalSynth'];
        const effectList = ['Distortion', 'AutoFilter', 'Reverb', 'Phaser', 'FeedbackDelay', 'Chorus', 'Vibrato', 'Tremolo', 'AutoPanner', 'PitchShift', 'FrequencyShifter', 'AutoWah', 'Chebyshev', 'PingPongDelay'];
        let effectsState = Object.fromEntries(effectList.map(fx => [fx, false]));

        // --- DOM ELEMENTS ---
        const dom = {
            generateButton: document.getElementById('generate-button'), replayButton: document.getElementById('replay-button'),
            synthSelector: document.getElementById('synth-selector'),
            resetButton: document.getElementById('reset-button'), killSwitch: document.getElementById('kill-switch'),
            logContainer: document.getElementById('scribe-log-container'), midiStatus: document.getElementById('midi-status'),
            midiDevices: document.getElementById('midi-devices'), connectMidiButton: document.getElementById('connect-midi-button'),
            midiNoteTargetToggle: document.getElementById('midi-note-target-toggle'), midiCCTargetToggle: document.getElementById('midi-cc-target-toggle'),
            effectsGrid: document.getElementById('effects-grid'), randomizeEffectsToggle: document.getElementById('randomize-effects-toggle'),
            alchemistDieButton: document.getElementById('alchemist-die-button'), disengageAllEffects: document.getElementById('disengage-all-effects'),
            activeEffectsControls: document.getElementById('active-effects-controls'), activeEffectsDropdown: document.getElementById('active-effects-dropdown'),
            loadCannonInput: document.getElementById('load-cannon-input'), loadCannonLabel: document.getElementById('load-cannon-label'),
            fireCannonButton: document.getElementById('fire-cannon-button'), ceasefireButton: document.getElementById('ceasefire-button'),
            cannonStatus: document.getElementById('cannon-status'),
            byrdsModeButton: document.getElementById('byrds-mode-button'),
        };
        
        // --- UTILITY & SETUP ---
        const logToScribe = (message, level = 'log') => { const p=document.createElement('p'); p.innerHTML=`[${new Date().toLocaleTimeString()}] ${message}`; const levelMap={'error':'log-error','warn':'log-warn','info':'log-info','success':'log-success'}; if(levelMap[level])p.className=levelMap[level]; dom.logContainer.appendChild(p); dom.logContainer.scrollTop=dom.logContainer.scrollHeight; };
        const random=(min,max)=>Math.random()*(max-min)+min; const maybe=(p=0.5)=>Math.random()<p; const fromList=(list)=>list[Math.floor(Math.random()*list.length)];
        const getChord=()=>{const r=fromList(['C','D','E','F','G','A','B'])+'4'; return[r,Tone.Frequency(r).transpose(maybe()?4:3).toNote(),Tone.Frequency(r).transpose(7).toNote()]};
        const scaleValue = (val, inMin, inMax, outMin, outMax) => ((val - inMin) * (outMax - outMin)) / (inMax - outMin) + outMin;
        
        // --- CORE AUDIO LOGIC ---
        const initializeAudioEngine = () => {
            logToScribe("Initializing audio engine...", 'info');
            if (masterLimiter) masterLimiter.dispose();
            if (masterVolume) masterVolume.dispose();
            if (effectsBus) effectsBus.dispose();

            masterLimiter = new Tone.Limiter(-6).toDestination(); 
            masterVolume = new Tone.Gain(1).connect(masterLimiter); 
            
            byrdsMode.split = new Tone.Split();
            byrdsMode.compressor = new Tone.Compressor(-40, 20);
            byrdsMode.makeupGain = new Tone.Gain(1.5).connect(masterVolume);
            byrdsMode.compressor.connect(byrdsMode.makeupGain);
            byrdsMode.pitchShift = new Tone.PitchShift(0);
            byrdsMode.highEndFilter = new Tone.Filter(5000, "lowpass");
            byrdsMode.vibrato = new Tone.Vibrato(random(3, 5), 0.02);
            byrdsMode.wet = new Tone.Gain(0).connect(byrdsMode.compressor);
            byrdsMode.dry = new Tone.Gain(1).connect(byrdsMode.compressor);
            byrdsMode.split.connect(byrdsMode.dry, 0, 0);
            byrdsMode.split.chain(byrdsMode.pitchShift, byrdsMode.highEndFilter, byrdsMode.vibrato, byrdsMode.wet);

            effectsBus = new Tone.Gain().connect(byrdsMode.split);

            logToScribe("Audio engine is live.",'success');
            isAudioReady = true;
        }

        const ensureAudioIsReady = async () => { 
            if(isAudioReady) return true; 
            try {
                logToScribe("Audio context starting...",'warn'); 
                await Tone.start(); 
                if(Tone.context.state==='running'){ 
                    Tone.context.latencyHint = 'interactive'; 
                    Tone.context.lookAhead = 0; 
                    initializeAudioEngine();
                    return true;
                }
            } catch(err) {
                logToScribe(`ERROR: Audio failed to start: ${err}`,'error'); 
                return false;
            } 
            return false; 
        };
        
        const disposeNodes = (nodeArray) => {
            if (Array.isArray(nodeArray)) {
                nodeArray.forEach(n => {
                    if (n && n.node && typeof n.node.dispose === 'function' && !n.node.disposed) {
                        n.node.dispose();
                    }
                });
            }
            return [];
        };

        const killAllAudio = (isFullReset = false) => {
            logToScribe(isFullReset ? "--- FULL ENGINE RESET ---" : "--- SILENCE ALL ---", 'warn');
        
            if (activeNode && !activeNode.disposed) {
                const oldNode = activeNode;
                if (typeof oldNode.releaseAll === 'function') {
                    oldNode.releaseAll(Tone.now()); 
                }
                oldNode.disconnect();
                setTimeout(() => {
                    if (!oldNode.disposed) oldNode.dispose();
                }, 2000); 
            }
            activeNode = null;
        
            if (cannonPlayer && !cannonPlayer.disposed) {
                cannonPlayer.stop();
            }
        
            if (isFullReset) {
                Tone.Transport.stop();
                Tone.Transport.cancel(0);
                if (cannonPlayer) {
                    cannonPlayer.dispose();
                    cannonPlayer = null;
                }
                lastSynthConfig = null;
                disposeNodes(activeEffects);
                activeEffects = [];
                initializeAudioEngine();
            }
        
            dom.replayButton.disabled = !lastSynthConfig;
            const anySource = (activeNode && !activeNode.disposed) || (cannonPlayer && cannonPlayer.loaded);
            dom.midiCCTargetToggle.disabled = !anySource;
            dom.midiNoteTargetToggle.disabled = !anySource;
        
            if (isFullReset) {
                dom.activeEffectsControls.classList.add('hidden');
                dom.fireCannonButton.disabled = true;
                dom.ceasefireButton.disabled = true;
                dom.cannonStatus.textContent = "The cannon is unloaded.";
                dom.loadCannonLabel.classList.remove('bg-green-700');
            }
        };

        const toggleByrdsMode = () => {
            byrdsMode.isActive = !byrdsMode.isActive;
            if (byrdsMode.isActive) {
                byrdsMode.wet.gain.rampTo(1, 0.1);
                byrdsMode.dry.gain.rampTo(0.5, 0.1);
                dom.byrdsModeButton.textContent = "Byrds Mode: ON";
                dom.byrdsModeButton.classList.add('active');
                logToScribe("Byrds Mode Engaged!", 'success');
            } else {
                byrdsMode.wet.gain.rampTo(0, 0.1);
                 byrdsMode.dry.gain.rampTo(1, 0.1);
                dom.byrdsModeButton.textContent = "Byrds Mode: OFF";
                dom.byrdsModeButton.classList.remove('active');
                 logToScribe("Byrds Mode Disengaged.", 'warn');
            }
        };

        const setByrdsPitch = (note) => {
            if (!byrdsMode.isActive) return;
            try {
                const midi = Tone.Frequency(note).toMidi();
                if (midi >= 71) { // B4 and above
                    byrdsMode.pitchShift.pitch = 0;
                    byrdsMode.vibrato.depth.value = random(0.05, 0.1);
                    byrdsMode.vibrato.frequency.value = random(5, 8);
                } else { // B flat 4 and below
                    byrdsMode.pitchShift.pitch = 12;
                    byrdsMode.vibrato.depth.value = random(0.01, 0.02);
                    byrdsMode.vibrato.frequency.value = random(3, 5);
                }
            } catch(e) {
                byrdsMode.pitchShift.pitch = 0;
            }
        };
        
        const createAndApplyEffects = async () => {
            logToScribe("Applying effects formula...", 'info');

            effectsBus.disconnect();
            disposeNodes(activeEffects);

            const chain = [];
            if(effectsState.Distortion) chain.push({name:'Distortion', node:new Tone.Distortion(random(0, 1))});
            if(effectsState.AutoFilter) chain.push({name:'AutoFilter', node:new Tone.AutoFilter(random(0.1, 10), random(100, 1500), random(1, 8)).start()});
            if(effectsState.Reverb) chain.push({name:'Reverb', node:new Tone.Reverb({decay: random(0.5, 8), preDelay: random(0.01, 0.5)})});
            if(effectsState.Phaser) chain.push({name:'Phaser', node:new Tone.Phaser({frequency:random(0.1, 20), octaves:random(1, 8), baseFrequency:random(100, 2000)})});
            if(effectsState.FeedbackDelay) chain.push({name:'FeedbackDelay', node:new Tone.FeedbackDelay(random(0, 0.8), random(0, 0.9))});
            if(effectsState.Chorus) chain.push({name:'Chorus', node:new Tone.Chorus(random(0.1, 10), random(1, 10), random(0.1, 0.9)).start()});
            if(effectsState.Vibrato) chain.push({name:'Vibrato', node:new Tone.Vibrato(random(0.1, 20), random(0, 1))});
            if(effectsState.Tremolo) chain.push({name:'Tremolo', node:new Tone.Tremolo(random(0.1, 20), random(0, 1)).start()});
            if(effectsState.AutoPanner) chain.push({name:'AutoPanner', node:new Tone.AutoPanner(random(0.1, 20)).start()});
            if(effectsState.PitchShift) chain.push({name:'PitchShift', node:new Tone.PitchShift(0)});
            if(effectsState.FrequencyShifter) chain.push({name:'FrequencyShifter', node:new Tone.FrequencyShifter(0)});
            if(effectsState.AutoWah) chain.push({name:'AutoWah', node:new Tone.AutoWah(50, 6, -30)});
            if(effectsState.Chebyshev) chain.push({name:'Chebyshev', node:new Tone.Chebyshev(Math.floor(random(1, 50)))});
            if(effectsState.PingPongDelay) chain.push({name:'PingPongDelay', node:new Tone.PingPongDelay("4n", 0.9)});
            
            activeEffects = chain;

            if (chain.length > 0) {
                effectsBus.chain(...chain.map(e => e.node), byrdsMode.split); 
            } else {
                effectsBus.connect(byrdsMode.split);
            }

            if (activeNode && !activeNode.disposed) activeNode.connect(effectsBus);
            if (cannonPlayer && cannonPlayer.loaded) cannonPlayer.connect(effectsBus);

            logToScribe(`Effects formula applied (${chain.length} effects).`, 'success');
            updateActiveEffectsDropdown();
            updateMIDIMap();
        };
        
        const buildSynthConfig = (type) => {
            let options={}, payload, duration=random(0.2,2.0), velocity=random(0.5,1);
            const safeEnvelope = { attack: 0.02, decay: 0.4, sustain: 0.5, release: 1.0 };
            
            if (type === 'Synth') { 
                payload=getChord(); 
                options={oscillator:{type:fromList(['fatsawtooth','fatsquare','fatsine', 'pwm', 'pulse'])}, envelope: safeEnvelope }; 
            } else if (type === 'MonoSynth') {
                 payload = 'C3';
                 options = { oscillator:{type:'sawtooth'}, envelope: safeEnvelope, filterEnvelope: { attack: 0.2, decay: 0.3, sustain: 0.6, release: 0.8, baseFrequency: 300, octaves: 4 } };
            } else if (type === 'MembraneSynth') { 
                payload = 'C2'; 
                options = { pitchDecay: random(0.01, 0.1), octaves: random(2, 10), envelope: safeEnvelope }; 
            } else if (type === 'MetalSynth') { 
                payload = null; 
                duration = random(0.1, 1.0);
                options = { frequency: random(50, 400), harmonicity: random(2, 10), modulationIndex: random(10, 40), envelope: safeEnvelope }; 
            } else if (type === 'DuoSynth') { 
                payload='C4'; 
                options = {vibratoAmount: random(0.1, 0.8), vibratoRate: random(1, 10), harmonicity: random(0.5, 2), voice0: {envelope: safeEnvelope}, voice1: {envelope: safeEnvelope} };
            } else { // FMSynth, AMSynth
                payload=fromList(['C3','E3','G3','C4']); 
                options = { harmonicity: random(0.5, 4), modulationIndex: random(5, 20), envelope: safeEnvelope, modulationEnvelope: safeEnvelope };
            }
            return {type, options, payload, duration, velocity};
        };
        
        const prepareAndPlaySynth = (config, triggerSound = false) => {
            try {
                killAllAudio(false); 

                const {type, options, payload, duration, velocity} = config;
                logToScribe(`${triggerSound ? "Activating" : "Preparing"}: ${type}`, 'info');

                if (type === 'MetalSynth') {
                    activeNode = new Tone.MetalSynth();
                } else {
                    activeNode = new Tone.PolySynth(Tone[type]);
                }
                activeNode.set(options);
                activeNode.connect(effectsBus);

                if (triggerSound) {
                    const firstNote = Array.isArray(payload) ? payload[0] : payload;
                    if (firstNote) setByrdsPitch(firstNote);

                    if (type === 'MetalSynth') {
                        activeNode.triggerAttackRelease(duration, undefined, velocity);
                    } else {
                        activeNode.triggerAttackRelease(payload, duration, undefined, velocity);
                    }
                }

                if (Tone.Transport.state !== 'started') Tone.Transport.start();
                logToScribe(`SOUND PRODUCED (${type}).`, 'success');
                dom.synthSelector.value = type;
                dom.midiCCTargetToggle.disabled = false; dom.midiNoteTargetToggle.disabled = false;
                dom.replayButton.disabled = false;
                midiCCTarget = 'synth';
                dom.midiCCTargetToggle.textContent = 'CC Control: Synth';
                updateMIDIMap();
            } catch (err) {
                logToScribe(`CRITICAL FORGE FAILURE: ${err.message}`, 'error');
            }
        };
        
        const handleReplay = () => {
            if (!lastSynthConfig || isGenerating) return;
            try {
                prepareAndPlaySynth(lastSynthConfig, true);
            } catch (err) {
                logToScribe(`CRITICAL RE-FORGE FAILURE: ${err.message}`, 'error');
            }
        }

        const handleGenerate = async (synthType = null, triggerSound = true) => {
            if (isGenerating) return;
            isGenerating = true;
            dom.generateButton.disabled = true;
            dom.synthSelector.disabled = true;

            try {
                if (triggerSound) logToScribe("Forge command received.");
                if (!await ensureAudioIsReady()) {
                    throw new Error("Audio engine failed to initialize.");
                }
                
                if (randomizeEffects && triggerSound) {
                    await rollAlchemistDie();
                } else {
                    await createAndApplyEffects();
                }

                const type = synthType || fromList(synthList);
                lastSynthConfig = buildSynthConfig(type);
                prepareAndPlaySynth(lastSynthConfig, triggerSound);

            } catch (error) {
                logToScribe(`ERROR during sound generation: ${error.message}`, 'error');
            } finally {
                isGenerating = false;
                dom.generateButton.disabled = false;
                dom.synthSelector.disabled = false;
            }
        };
        
        // --- UI & EVENT LISTENERS ---
        const rollAlchemistDie = async () => {
            logToScribe("Rolling the Alchemist's Die...", 'info');
            for (const key in effectsState) effectsState[key] = maybe(0.35);
            updateEffectButtons();
            await createAndApplyEffects();
        };
        const updateEffectButtons = () => { for (const n in effectsState) { const b=document.getElementById(`effect-btn-${n}`); if(b) b.classList.toggle('active',effectsState[n]); }};
        const updateActiveEffectsDropdown = () => { dom.activeEffectsDropdown.innerHTML = ''; if (activeEffects.length > 0) { activeEffects.forEach(e => { const o=document.createElement('option'); o.value=o.textContent=e.name; dom.activeEffectsDropdown.appendChild(o); }); dom.activeEffectsControls.classList.remove('hidden'); } else { dom.activeEffectsControls.classList.add('hidden'); } };

        // --- SAMPLER LOGIC ---
        const handleLoadCannon = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            logToScribe(`Loading ${file.name}...`, 'info');
            await ensureAudioIsReady();
            if (cannonPlayer) cannonPlayer.dispose();
            const url = URL.createObjectURL(file);
            cannonPlayer = new Tone.Player(url, () => {
                logToScribe("Cannon is loaded!", 'success');
                dom.cannonStatus.textContent = `Loaded: ${file.name}`;
                dom.loadCannonLabel.classList.add('bg-green-700');
                dom.fireCannonButton.disabled = false;
                dom.midiNoteTargetToggle.disabled = false;
                cannonPlayer.connect(effectsBus);
            });
        };

        const handleFireCannon = () => { if (cannonPlayer?.loaded) { setByrdsPitch("C4"); cannonPlayer.start(); dom.ceasefireButton.disabled=false; } };
        const handleCeasefire = () => { if (cannonPlayer) { cannonPlayer.stop(); dom.ceasefireButton.disabled=true; } };

        // --- MIDI LOGIC ---
        const handleMIDIMessage = (event) => {
            const [command, data1, data2] = event.data;
            const type = command & 0xf0;
            const now = Tone.now();
            
            if (type === 0x90 && data2 > 0) {
                const freq = Tone.Frequency(data1, "midi");
                setByrdsPitch(freq);
                if (midiNoteTarget === 'sampler' && cannonPlayer?.loaded) { cannonPlayer.playbackRate=freq.toFrequency()/Tone.Frequency("C4").toFrequency(); cannonPlayer.start(now); }
                else if (midiNoteTarget === 'synth' && activeNode && typeof activeNode.triggerAttack === 'function' && !activeNode.disposed) { activeNode.triggerAttack(freq, now, data2/127); }
            }
            if (type === 0x80 || (type === 0x90 && data2 === 0)) {
                if (midiNoteTarget === 'synth' && activeNode && typeof activeNode.triggerRelease === 'function' && !activeNode.disposed) { const freq=Tone.Frequency(data1,"midi"); activeNode.triggerRelease(freq, now); }
            }
            if (type === 0xE0) { 
                 if (activeNode && !activeNode.disposed) { 
                     // Standard MIDI pitch bend calculation
                     const bend = (((data2 << 7) | data1) - 8192) / 8192; 
                     activeNode.set({detune: bend * 400}); // Bend range of +/- 4 semitones
                 }
            }
            if (type === 0xB0) {
                const cc = data1; const value = data2;
                if(midiCCMap[cc]) {
                    midiCCMap[cc].setter(scaleValue(value, 0, 127, midiCCMap[cc].min, midiCCMap[cc].max));
                }
            }
        };
        
        const updateMIDIMap = () => {
            midiCCMap = {};
            logToScribe(`Updating MIDI CC map for: ${midiCCTarget}`, 'info');
        
            const mapParam = (cc, setter, min, max, name) => {
                if (setter) {
                    midiCCMap[cc] = { setter, min, max };
                    logToScribe(`CC ${cc} -> ${name}`, 'info');
                }
            };
        
            if (midiCCTarget === 'synth' && activeNode && lastSynthConfig && !activeNode.disposed) {
                const setEnv = (param, value) => activeNode.set({ envelope: { [param]: value } });
                mapParam(71, v => setEnv('attack', v), 0.01, 2, 'Attack');
                mapParam(72, v => setEnv('decay', v), 0.01, 2, 'Decay');
                mapParam(73, v => setEnv('sustain', v), 0, 1, 'Sustain');
                mapParam(74, v => setEnv('release', v), 0.01, 4, 'Release');
                mapParam(75, v => activeNode.set({ detune: v }), -1200, 1200, 'Detune');
        
                switch(lastSynthConfig.type) {
                    case 'MonoSynth':
                        mapParam(1, v => activeNode.set({ filterEnvelope: { baseFrequency: v } }), 100, 8000, 'Mod Wheel (Filter Freq)');
                        mapParam(76, v => activeNode.set({ filterEnvelope: { attack: v } }), 0.01, 2, 'Filt Env Atk');
                        mapParam(77, v => activeNode.set({ filterEnvelope: { release: v } }), 0.01, 4, 'Filt Env Rel');
                        mapParam(78, v => activeNode.set({ filterEnvelope: { baseFrequency: v } }), 100, 5000, 'Filt Env Freq');
                        break;
                    case 'DuoSynth':
                        mapParam(1, v => activeNode.set({ vibratoAmount: v }), 0, 1, 'Mod Wheel (Vibrato)');
                        mapParam(76, v => activeNode.set({ vibratoRate: v }), 0.1, 20, 'Vibrato Rate');
                        mapParam(77, v => activeNode.set({ harmonicity: v }), 0.1, 10, 'Harmonicity');
                        mapParam(78, v => activeNode.set({ vibratoAmount: v }), 0, 1, 'Vibrato Amt');
                        break;
                    case 'MetalSynth':
                        mapParam(1, v => activeNode.set({ modulationIndex: v }), 1, 60, 'Mod Wheel (Mod Index)');
                        mapParam(76, v => activeNode.set({ harmonicity: v }), 0.1, 20, 'Harmonicity');
                        mapParam(77, v => activeNode.set({ modulationIndex: v }), 1, 50, 'Mod Index');
                        mapParam(78, v => activeNode.set({ octaves: v }), 0.1, 8, 'Octaves');
                        break;
                    default: // FMSynth, AMSynth, Synth
                        mapParam(1, v => activeNode.set({ modulationIndex: v }), 1, 50, 'Mod Wheel (Mod Index)');
                        mapParam(76, v => activeNode.set({ harmonicity: v }), 0.1, 20, 'Harmonicity');
                        mapParam(77, v => activeNode.set({ modulationIndex: v }), 1, 50, 'Mod Index');
                        if (lastSynthConfig.type === 'FMSynth' || lastSynthConfig.type === 'AMSynth') {
                            mapParam(78, v => activeNode.set({ modulationEnvelope: { attack: v, release: v } }), 0.01, 2, 'Mod Env A/R');
                        }
                        break;
                }
            } else if (midiCCTarget === 'effects') {
                const effect = activeEffects.find(e => e.name === dom.activeEffectsDropdown.value);
                if (effect && !effect.node.disposed) {
                    const { node } = effect;
                    mapParam(71, v => node.wet.value = v, 0, 1, `${node.name} Mix`);
                    switch(effect.name) {
                        case 'Distortion': mapParam(72, v=>node.distortion=v, 0, 1, 'Amount'); mapParam(73, v=>node.oversample=(v > 0.5 ? '4x' : 'none'), 0, 1, 'Oversample'); break;
                        case 'AutoFilter': mapParam(72, v=>node.frequency.value=v, 0.1, 20, 'Rate'); mapParam(73, v=>node.depth.value=v, 0.1, 1, 'Depth'); mapParam(74, v=>node.filter.Q.value=v, 1, 20, 'Filter Q'); mapParam(75, v=>node.baseFrequency.value=v, 100, 4000, 'Base Freq'); break;
                        case 'Reverb': mapParam(72, v=>node.decay=v, 0.1, 30, 'Decay'); mapParam(73, v=>node.preDelay=v, 0.01, 1, 'PreDelay'); break;
                        case 'Phaser': mapParam(72, v=>node.frequency.value=v, 0.1, 20, 'Rate'); mapParam(73, v=>node.octaves=v, 1, 8, 'Octaves'); mapParam(74, v=>node.Q.value=v, 0, 20, 'Q'); mapParam(75, v=>node.baseFrequency.value=v, 100, 4000, 'Base Freq'); break;
                        case 'FeedbackDelay': case 'PingPongDelay': mapParam(72, v=>node.delayTime.value=v, 0.01, 1, 'Time'); mapParam(73, v=>node.feedback.value=v, 0, 0.95, 'Feedback'); break;
                        case 'Chorus': mapParam(72, v=>node.frequency.value=v, 0.1, 20, 'Rate'); mapParam(73, v=>node.depth=v, 0, 1, 'Depth'); mapParam(74, v=>node.delayTime=v, 1, 10, 'Delay'); mapParam(75, v=>node.feedback.value=v, 0, 0.9, 'Feedback'); break;
                        case 'Vibrato': mapParam(72, v=>node.frequency.value=v, 0.1, 40, 'Rate'); mapParam(73, v=>node.depth.value=v, 0, 1, 'Depth'); break;
                        case 'Tremolo': mapParam(72, v=>node.frequency.value=v, 0.1, 40, 'Rate'); mapParam(73, v=>node.depth.value=v, 0, 1, 'Depth'); break;
                        case 'AutoPanner': mapParam(72, v=>node.frequency.value=v, 0.1, 40, 'Rate'); mapParam(73, v=>node.depth.value=v, 0, 1, 'Depth'); break;
                        case 'PitchShift': mapParam(72, v=>node.pitch=v, -24, 24, 'Pitch (ST)'); mapParam(73, v=>node.windowSize=v, 0.03, 1, 'Window'); mapParam(74, v=>node.delayTime.value=v, 0, 1, 'Delay'); mapParam(75, v=>node.feedback.value=v, 0, 0.9, 'Feedback'); break;
                        case 'FrequencyShifter': mapParam(72, v=>node.frequency.value=v, -1000, 1000, 'Frequency'); break;
                        case 'AutoWah': mapParam(72, v=>node.baseFrequency=v, 50, 2000, 'Base Freq'); mapParam(73, v=>node.octaves=v, 1, 8, 'Octaves'); mapParam(74, v=>node.sensitivity=v, -40, 0, 'Sensitivity'); mapParam(75, v=>node.Q.value=v, 1, 10, 'Q'); break;
                        case 'Chebyshev': mapParam(72, v=>node.order=Math.floor(v), 1, 100, 'Order'); break;
                    }
                }
            }
        };
        
        const setupMIDI = async () => {
            if (midiAccess) {
                logToScribe("Re-scanning for MIDI devices...", "warn");
                const inputs = Array.from(midiAccess.inputs.values());
                dom.midiDevices.innerHTML = '';
                 if (inputs.length === 0) { 
                    logToScribe("No MIDI input devices found.", 'warn'); 
                    dom.midiDevices.classList.add('hidden');
                    dom.midiStatus.textContent = 'No MIDI devices found.';
                    return; 
                }
                inputs.forEach(input => { const opt=document.createElement('option'); opt.value=input.id; opt.textContent=input.name; dom.midiDevices.appendChild(opt); });
                if (inputs.length > 0) {
                    attachMIDIListener(inputs[0]);
                }
                return;
            }
            if (!navigator.requestMIDIAccess) { 
                logToScribe("Web MIDI API not supported in this browser.", 'error'); 
                dom.midiStatus.textContent = 'Web MIDI API not supported.';
                return; 
            }
            try {
                const newMidiAccess = await navigator.requestMIDIAccess();
                logToScribe("MIDI access granted!", 'success');
                midiAccess = newMidiAccess;
                midiAccess.onstatechange = (e) => { 
                    logToScribe(`MIDI state change: ${e.port.name} ${e.port.state}`, 'info'); 
                    setupMIDI(); 
                };
                setupMIDI(); 
            } catch (err) { 
                logToScribe(`MIDI access denied: ${err.name}`, 'error');
                dom.midiStatus.textContent = `MIDI access denied.`;
            }
        };
        const attachMIDIListener = (input) => { 
            if(!input) return; 
            if(activeMIDIInput) {
                activeMIDIInput.onmidimessage = null;
            }
            activeMIDIInput = input; 
            activeMIDIInput.onmidimessage = handleMIDIMessage; 
            dom.midiStatus.textContent = `Connected to: ${activeMIDIInput.name}`; 
            dom.midiDevices.classList.remove('hidden'); 
            dom.midiDevices.disabled = false;
            dom.midiDevices.value = activeMIDIInput.id;
            logToScribe(`Listening for MIDI on ${activeMIDIInput.name}`,'success');
        };

        // --- INITIALIZATION ---
        (function init() {
            logToScribe("Awaiting the first command...");
            synthList.forEach(synthName => {
                const option = document.createElement('option');
                option.value = synthName;
                option.textContent = synthName;
                dom.synthSelector.appendChild(option);
            });

            dom.generateButton.addEventListener('click', () => handleGenerate(null, true));
            dom.replayButton.addEventListener('click', handleReplay);
            dom.synthSelector.addEventListener('change', (e) => handleGenerate(e.target.value, false));
            dom.resetButton.addEventListener('click', () => killAllAudio(true));
            dom.killSwitch.addEventListener('click', () => killAllAudio(false));
            dom.connectMidiButton.addEventListener('click', setupMIDI);
            dom.loadCannonInput.addEventListener('change', handleLoadCannon);
            dom.fireCannonButton.addEventListener('click', handleFireCannon);
            dom.ceasefireButton.addEventListener('click', handleCeasefire);
            dom.randomizeEffectsToggle.addEventListener('click', () => { randomizeEffects=!randomizeEffects; dom.randomizeEffectsToggle.textContent=`Randomize FX: ${randomizeEffects?'ON':'OFF'}`;});
            dom.alchemistDieButton.addEventListener('click', rollAlchemistDie);
            dom.byrdsModeButton.addEventListener('click', toggleByrdsMode);
            dom.disengageAllEffects.addEventListener('click', async () => { for (const k in effectsState) effectsState[k]=false; updateEffectButtons(); await createAndApplyEffects(); });
            dom.midiCCTargetToggle.addEventListener('click', () => { midiCCTarget=midiCCTarget==='synth'?'effects':'synth'; dom.midiCCTargetToggle.textContent=`CC Control: ${midiCCTarget.charAt(0).toUpperCase()+midiCCTarget.slice(1)}`; updateMIDIMap(); });
            dom.midiNoteTargetToggle.addEventListener('click', () => { midiNoteTarget=midiNoteTarget==='synth'?'sampler':'synth'; dom.midiNoteTargetToggle.textContent=`MIDI Triggers: ${midiNoteTarget.charAt(0).toUpperCase()+midiNoteTarget.slice(1)}`; });
            dom.activeEffectsDropdown.addEventListener('change', updateMIDIMap);
            dom.midiDevices.addEventListener('change', (e) => { if(midiAccess) attachMIDIListener(midiAccess.inputs.get(e.target.value)); });
            
            effectList.forEach(name => {
                const btn = document.createElement('button');
                btn.id = `effect-btn-${name}`;
                btn.textContent = name;
                btn.className = 'effect-button font-bold py-2 px-3 rounded text-sm';
                btn.addEventListener('click', async () => {
                    const wasActive = effectsState[name];
                    effectsState[name] = !effectsState[name];

                    updateEffectButtons();
                    await createAndApplyEffects();

                    if (!wasActive && effectsState[name]) {
                        if (activeEffects.length > 0) {
                            logToScribe(`Focusing MIDI CC on ${name}.`, 'info');
                            midiCCTarget = 'effects';
                            dom.midiCCTargetToggle.textContent = 'CC Control: Effects';
                            
                            dom.activeEffectsDropdown.value = name;

                            updateMIDIMap();
                        }
                    }
                });
                dom.effectsGrid.appendChild(btn);
            });
        })();
    });
    </script>
</body>
</html>